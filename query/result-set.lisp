;; -*- mode: Lisp; Syntax: Common-Lisp; -*-
;;;
;;; Copyright (c) 2006 by the authors.
;;;
;;; See LICENCE for details.

(in-package :cl-perec)

(declaim (optimize (debug 3) (safety 3) (speed 0)))

;;;; This file contains classes and methods for storing, filtering, mapping
;;;; results of SQL queries.
;;;;
;;;; TODO: filters are not lazy
;;;; TODO: scrolled-result-set should add an ORDER-BY clause to the query to make it deterministic


;;;
;;; Result-set
;;;

(defclass* result-set ()
  ())

(defgeneric open-result-set (type sql-query)
  (:documentation "Returns a new result-set which is the result of the sql-query."))

(defgeneric close-result-set (result-set)
  (:documentation "Closes the result-set. After this operation the result-set cannot be accessed.")
  (:method (result-set)
           (values)))

(defgeneric revive-result-set! (result-set)
  (:documentation "Refreshes the result set to be valid in the current transaction.")
  (:method (result-set)
           (values)))

(defgeneric record-count-of (result-set)
  (:documentation "Returns the number of records in RESULT-SET.")
  (:method ((result-set abstract-container))
           (size result-set)))

(defgeneric records-of (result-set &optional start end)
  (:documentation "Returns records of RESULT-SET as a sequence from START index
 (inclusive, default is 0) to END index (exclusive, default is the number of records).")
  (:method :around (result-set &optional (start 0) end)
           (bind ((size (record-count-of result-set)))
             (unless end (setf end size))
             (unless (<= 0 start size) (error "Start index ~D out of range for result-set: ~A" start result-set))
             (unless (<= 0 end size) (error "End index ~D out of range for result-set: ~A" end result-set))
             (unless (<= start end) (error "Start index ~D is greater than end index ~D" start end))
             (if (= start end)
                 nil
                 (call-next-method result-set start end))))
  (:method ((result-set iteratable-container-mixin) &optional start end)
           (iter (for i from start below end)
                 (collect (nth-element result-set i)))) ; FIXME: don't use nth-element here, O(N^2)
  (:method ((result-set array-container) &optional start end)
           (iter (for i from start below end)
                 (collect (nth-element result-set i)))))

(defgeneric to-list (result &optional flatp)
  (:documentation "Converts the result to a list.
If FLATP is true then the rows are flattened (useful when they contain only one column).")
  (:method ((result list) &optional flatp)
           (if flatp (apply 'nconc result) result))
  (:method ((result contents-as-list-mixin) &optional flatp)
           (to-list (contents result) flatp))
  (:method ((result iteratable-container-mixin) &optional flatp)
           (iter (with iterator = (make-iterator result))
                 (while (current-element-p iterator))
                 (if flatp
                     (appending (coerce (current-element iterator) 'list))
                     (collect (coerce (current-element iterator) 'list)))
                 (move-forward iterator)))
  (:method ((result result-set) &optional flatp)
           (if flatp
               (iter (for record in-sequence (records-of result))
                     (appending (coerce record 'list)))
               (coerce (records-of result) 'list)))
  (:method ((result scroll) &optional flatp) ; for testing only
           (iter outer                       ; (called from code generated by the debug compiler)

                 (for page from 0)
                 (for dummy first (first-page! result) then (next-page! result))
                 (while (= page (page result)))
                 (for elements = (elements result))
                 (while (> (length elements) 0))
                 (iter (for element in-sequence elements)
                       (in outer
                           (if flatp
                               (appending (coerce element 'list))
                               (collect (coerce element 'list))))))))

(defgeneric to-scroll (result-set)
  (:documentation "Converts the result set to a scroll.")
  (:method ((result-set scroll))
           result-set)
  (:method ((result-set result-set))
           (make-instance 'result-set-scroll :result-set result-set)))

;;;----------------------------------------------------------------------------
;;; Scroll
;;;
(defclass* result-set-scroll (fixed-size-scroll result-set)
  ((inner-result-set :initarg :result-set)
   (page 0 :accessor page)
   (page-size 10 :accessor page-size)))

(defmethod element-count ((scroll result-set-scroll))
  (record-count-of (inner-result-set-of scroll)))

(defmethod page-count ((scroll result-set-scroll))
  (values (ceiling (/ (element-count scroll) (page-size scroll)))))

(defmethod elements ((scroll result-set-scroll))
  (bind ((inner (inner-result-set-of scroll))
         (start (* (page scroll) (page-size scroll)))
         (end (min (+ start (page-size scroll)) (record-count-of inner)))
         (records (when (> end start) (records-of inner start end))))
    (coerce records 'vector)))

(defmethod revive-scroll! ((scroll result-set-scroll))
  (revive-result-set! scroll))

(defmethod revive-result-set! ((result-set result-set-scroll))
  (revive-result-set! (inner-result-set-of result-set)))

(defmethod close-result-set ((result-set result-set-scroll))
  (close-result-set (inner-result-set-of result-set)))

;;;----------------------------------------------------------------------------
;;; Transformers

;;;
;;; Base class for transformers
;;;
(defclass* result-set-transformer (result-set)
  ((inner :type result-set)))

(defmethod close-result-set ((result-set result-set-transformer))
  (close-result-set (inner-of result-set)))

(defmethod revive-result-set! ((result-set result-set-transformer))
  (revive-result-set! (inner-of result-set))
  (update-contents! result-set))

(defgeneric update-contents! (result-set)
  (:method (result-set)
           (values)))

;;;
;;; Ordered result-set
;;;
;;; TODO: lazyness

(defclass* ordered-result-set (list-container result-set-transformer)
  ((lessp :type function)))

(defun make-ordered-result-set (result-set lessp)
  (bind ((instance (make-instance 'ordered-result-set :inner result-set :lessp lessp)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set ordered-result-set))
  (with-slots (contents inner lessp) result-set
    (setf contents (sort (records-of inner) lessp)))
  (values))

;;;
;;; Filtered result-set
;;;
;;; TODO: lazyness

(defclass* filtered-result-set (list-container result-set-transformer)
  ((predicate :type function)))

(defun make-filtered-result-set (result-set predicate)
  (bind ((instance (make-instance 'filtered-result-set :inner result-set :predicate predicate)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set filtered-result-set))
  (with-slots (contents inner predicate) result-set
    (setf contents (collect-elements (records-of inner) :filter predicate)))
  (values))

;;;
;;; Grouping
;;;

(defclass* grouped-result-set (list-container result-set-transformer)
  ((group-by :type function)
   (collect-fn :type function)
   (map-fn :type function)))

(defun make-grouped-result-set (result-set group-by collect-fn map-fn)
  (bind ((instance (make-instance 'grouped-result-set :inner result-set :group-by group-by
                                  :collect-fn collect-fn :map-fn map-fn)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set grouped-result-set))
  (with-slots (contents inner group-by collect-fn map-fn) result-set
    (bind ((ht (make-hash-table :test 'equal)))
      (labels ((aggregate (key record)
                 (bind ((val (gethash key ht (funcall collect-fn)))
                        (new-val (funcall collect-fn val record)))
                   (setf (gethash key ht) new-val))))
       (iter (for record in-sequence (records-of inner))
             (for key = (funcall group-by record))
             (aggregate key record))
       (setf contents
             (iter (for record in-sequence (records-of inner))
                   (for key = (funcall group-by record))
                   (for aggregated-values = (gethash key ht (funcall collect-fn)))
                   (collect (funcall map-fn record aggregated-values))))))))

;;;
;;; Unique filtered result-set
;;;
;;; TODO: lazyness
(defclass* unique-result-set (list-container result-set-transformer)
  ((test-fn :type function)))

(defun make-unique-result-set (result-set &key (test #'equal))
  (bind ((instance (make-instance 'unique-result-set :inner result-set :test-fn test)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set unique-result-set))
  (with-slots (contents inner test-fn) result-set
    (setf contents
          (with-iterator (iterator (records-of inner) :unique #t :test test-fn)
            (collect-elements iterator)))))

;;;
;;; Mapped result-set
;;;
(defclass* mapped-result-set (result-set-transformer)
  ((map-fn :type function)))

(defun make-mapped-result-set (result-set map-fn)
  (make-instance 'mapped-result-set :inner result-set :map-fn map-fn))

(defmethod record-count-of ((result-set mapped-result-set))
  (record-count-of (inner-of result-set)))

(defmethod records-of ((result-set mapped-result-set) &optional start end)
  (collect-elements (records-of (inner-of result-set) start end)
                    :transform (map-fn-of result-set)))

;;;----------------------------------------------------------------------------
;;; Sources

;;;
;;; List result-set
;;;
(defclass* list-result-set (list-container result-set)
  ())

(defun make-list-result-set (list)
  (aprog1
    (make-instance 'list-result-set)
    (setf (contents it) list)))

(defmethod revive-result-set! ((result-set list-result-set))
  (dolist (record (contents result-set))
    (mapl #L(when (persistent-object-p (car !1)) (revive-instance (car !1)))
          record)))


;;;
;;; Simple SQL result set
;;;
(defclass* simple-result-set (list-container result-set)
  ((sql-query))
  (:documentation "Retrieves all records at once as a list."))

(defmethod open-result-set ((type (eql 'list)) sql-query)
  (bind ((instance (make-instance 'simple-result-set :sql-query sql-query)))
    (revive-result-set! instance)
    instance))

(defmethod revive-result-set! ((result-set simple-result-set))
  (setf (contents result-set) (execute (sql-query-of result-set))))

;;;
;;; Scrolled SQL result set
;;;
(defclass* scrolled-result-set (result-set)
  ((record-count :type integer)
   (sql-query))
  (:documentation "Retrieves the records using OFFSET and LIMIT in the SQL query."))

(defmethod open-result-set ((type (eql 'scroll)) sql-query)
  (bind ((instance (make-instance 'scrolled-result-set :sql-query sql-query)))
    (revive-result-set! instance)
    instance))

(defmethod revive-result-set! ((result-set scrolled-result-set))
  (with-slots (sql-query) result-set
    (bind ((columns (cl-rdbms::columns-of sql-query)))
      (setf (cl-rdbms::columns-of sql-query) (list (cl-rdbms::sql-count-*))
            (cl-rdbms::offset-of sql-query) nil
            (cl-rdbms::limit-of sql-query) nil
            (record-count-of result-set) (first (first (execute sql-query)))
            (cl-rdbms::columns-of sql-query) columns)))
  (values))

(defmethod records-of ((result-set scrolled-result-set) &optional start end)
  (setf (cl-rdbms::offset-of (sql-query-of result-set)) start
        (cl-rdbms::limit-of (sql-query-of result-set)) (- end start))
  (execute (sql-query-of result-set)))

;;;
;;; Lazy SQL result-set (postgres only)
;;;
;; TODO: resurrect
#|
(defclass* lazy-result-set (result-set)
  ((clsql-result-set :type clsql-postgresql::postgresql-result-set)
   (current-record :type list))
  (:documentation "Retrieves the records using an SQL cursor."))

(defmethod open-result-set ((type (eql 'lazy)) sql-query)
  (assert (typep *database* 'postgresql))
  (bind (((values clsql-result-set num-of-columns num-of-rows)
          (clsql-sys:database-query-result-set sql-query database
                                               :full-set t
                                               :result-types :auto)))
    (make-instance 'lazy-result-set
                   :clsql-result-set clsql-result-set
                   :current-record (make-list num-of-columns))))

(defmethod close-result-set ((result-set lazy-result-set))
  (clsql-sys:database-dump-result-set (clsql-result-set-of result-set)
                                      (database-of result-set)))

(defmethod record-count-of ((result-set lazy-result-set))
  (clsql-postgresql::postgresql-result-set-num-tuples (clsql-result-set-of result-set)))

(defmethod records-of ((result-set lazy-result-set) &optional start end)
  (iter (for i from start below end)
        (setf (clsql-postgresql::postgresql-result-set-tuple-index
               (clsql-result-set-of result-set))
              i)
        (clsql-sys:database-store-next-row (clsql-result-set-of result-set)
                                           (database-of result-set)
                                           (current-record-of result-set))
        (collect (copy-list (current-record-of result-set)))))
|#